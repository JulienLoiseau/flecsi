

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Topology Design Idioms &mdash; FleCSI 2.-1 (devel) documentation</title>
  

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  
    <link rel="canonical" href="https://flecsi.orgsrc/developer-guide/topology.html"/>
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Core Guide" href="../core-guide.html" />
    <link rel="prev" title="Data Model" href="data.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html">
          

          
            
            <img src="../../_static/flecsi.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                Version: 2.-1 (devel)
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../build.html">Build &amp; Install</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user-guide.html">User Guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../developer-guide.html">Developer Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="execution.html">Task Invocation</a></li>
<li class="toctree-l2"><a class="reference internal" href="execution.html#task-execution">Task Execution</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html">Data Model</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Topology Design Idioms</a></li>
<li class="toctree-l2"><a class="reference internal" href="#adding-new-topologies">Adding New Topologies</a></li>
<li class="toctree-l2"><a class="reference internal" href="#topology-initialization-workflow">Topology Initialization Workflow</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../core-guide.html">Core Guide</a></li>
<li class="toctree-l1"><a class="reference external" href="http://laristra.github.io/flecsi/doxygen">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../team.html">Contributors</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">FleCSI</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../developer-guide.html">Developer Guide</a> &raquo;</li>
        
      <li>Topology Design Idioms</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/src/developer-guide/topology.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="topology-design-idioms">
<h1>Topology Design Idioms<a class="headerlink" href="#topology-design-idioms" title="Permalink to this headline">Â¶</a></h1>
<p>FleCSI uses three C++ idioms to implement topology types:
template specialization, template function overload, and tuple walkers.</p>
<ul>
<li><p><strong>Template Specialization</strong> <br />
Explicit or partial template specializations use C++ type inference to
match a template type parameter to a specific implementation, thus
allowing users to customize the behavior of a class or struct
depending on the type of the parameter that is passed:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Unspecialized (default) behavior.</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">TYPE</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">type</span> <span class="p">{};</span>

<span class="k">template</span><span class="o">&lt;&gt;</span>
<span class="k">struct</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">match_type_one_t</span><span class="o">&gt;</span> <span class="p">{</span>

  <span class="k">static</span> <span class="kt">void</span> <span class="n">method</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Implementation for type one.</span>
  <span class="p">}</span> <span class="c1">// method</span>

<span class="p">};</span> <span class="c1">// struct type</span>

<span class="k">template</span><span class="o">&lt;&gt;</span>
<span class="k">struct</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">match_type_two_t</span><span class="o">&gt;</span> <span class="p">{</span>

  <span class="k">static</span> <span class="kt">void</span> <span class="n">method</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Implementation for type two.</span>
  <span class="p">}</span> <span class="c1">// method</span>

<span class="p">};</span> <span class="c1">// struct type</span>
</pre></div>
</div>
<p>The distinction between <em>explicit</em> and <em>partial</em> specialization is
whether or not the specialized type is fully (explicit) or partially
qualified, i.e., partially specialized types leave some template
parameters unspecified.</p>
</li>
<li><p><strong>Template Function Overload</strong> <br />
Template function overloads are similar to template specialization,
but allow specialization of a method or function:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">enclosing_type_t</span> <span class="p">{</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">TYPE</span><span class="o">&gt;</span>
  <span class="kt">void</span> <span class="n">method</span><span class="p">(</span><span class="n">type_one</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Implementation for type one.</span>
  <span class="p">}</span> <span class="c1">// method</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">TYPE</span><span class="o">&gt;</span>
  <span class="kt">void</span> <span class="n">method</span><span class="p">(</span><span class="n">type_two</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Implementation for type two.</span>
  <span class="p">}</span> <span class="c1">// method</span>

<span class="p">};</span> <span class="c1">// struct enclosing_type_t</span>
</pre></div>
</div>
</li>
<li><p><strong>Tuple Walker</strong> <br />
The tuple walker idiom is really a calling technique used in
conjunction with template function overload that applies a <em>visit</em>
method, defined via the function template overload, to each
<em>type</em> or <em>value</em> of a
<a class="reference external" href="https://en.cppreference.com/w/cpp/utility/tuple">std::tuple</a>. The
distinction between tuple types and values is an important one, as it
distinguishes between static (type information, available at compile
time) and dynamic (variable information, available at runtime) state.</p>
<p>An example of FleCSIâs use of the tuple walker idiom, applied to
dynamic tuple values, is the <em>task_prologue_t</em> type, used to add region
requirements for the Legion implementation of <em>flecsi_execute_task</em>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nl">task_prologue_t</span> <span class="p">:</span> <span class="k">public</span>
<span class="n">flecsi</span><span class="o">::</span><span class="n">utils</span><span class="o">::</span><span class="n">tuple_walker</span><span class="o">&lt;</span><span class="n">task_prologue_t</span><span class="o">&gt;</span> <span class="p">{</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">DATA_TYPE</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">PRIVILEGES</span><span class="o">&gt;</span>
  <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">index_t</span><span class="o">::</span><span class="n">accessor</span><span class="o">&lt;</span><span class="n">DATA_TYPE</span><span class="p">,</span> <span class="n">PRIVILEGES</span><span class="o">&gt;</span> <span class="o">&amp;</span>
  <span class="n">accessor</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Implmentation for type</span>
    <span class="c1">// index_t::accessor&lt;DATA_TYPE, PRIVILEGES&gt;.</span>
  <span class="p">}</span> <span class="c1">// visit</span>

<span class="p">};</span> <span class="c1">// struct task_prologue_t</span>
</pre></div>
</div>
<p>You may notice that I lied to you before about there only being three
idioms: Our tuple walker type also uses the CRTP idiom documented
<a class="reference external" href="http://laristra.github.io/flecsi/src/developer-guide/patterns/CRTP.html">here</a>.</p>
</li>
</ul>
</div>
<div class="section" id="adding-new-topologies">
<h1>Adding New Topologies<a class="headerlink" href="#adding-new-topologies" title="Permalink to this headline">Â¶</a></h1>
<ol class="arabic">
<li><p><strong>Topology Type</strong>: Add a new subdirectory to the <em>flecsi/topology</em>
directory named for the new topology type, e.g., <em>ntree</em>.</p>
<p>This subdirectory should include:</p>
<ul>
<li><p>interface.h: This file defines the topology interface, e.g.,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">flecsi</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">topology</span> <span class="p">{</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">POLICY_TYPE</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nl">ntree</span> <span class="p">:</span> <span class="n">ntree_base</span> <span class="p">{</span>

  <span class="c1">// interface ...</span>

<span class="p">};</span> <span class="c1">// struct ntree</span>

<span class="p">}</span> <span class="c1">// namespace flecsi</span>
<span class="p">}</span> <span class="c1">// namespace topology</span>
</pre></div>
</div>
</li>
<li><p>types.h: This file defines types that are used by FleCSI, and by
the new topology type. At a minimum, this file should define a base
type from which the new topology type shall inherit, and a
<em>coloring</em> type. The base class will be used to identify
specializations of the new type in explicit/partial specializations
and template function overloads. The coloring type should include
whatever interface and data members are required to form a
distributed-memory representation of the new topology:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">ntree_base</span> <span class="p">{</span>

<span class="k">using</span> <span class="n">coloring</span> <span class="o">=</span> <span class="n">ntree_coloring_t</span><span class="p">;</span>

  <span class="c1">// interface ...</span>

<span class="p">};</span> <span class="c1">// struct ntree_base</span>
</pre></div>
</div>
<p>The base type should be named consistently with the new topology
type name, and should follow FleCSI naming conventions. The base
type must define the public <em>coloring</em> type.</p>
</li>
</ul>
</li>
<li><p><strong>Topology Registration</strong>: Define a partial specialization of the
<em>topology_registration</em> type in
<em>flecsi/data/topology_registration.h</em>. This type must
implement a <em>register_fields</em> method that adds the fields required to
represent the meta data associated with an instance of the new
topology type.</p></li>
<li><p><strong>Topology Instance</strong>: Define runtime-specific topology instance types in
<em>data/runtime/topologies.h</em>, where <em>runtime</em> is implemented for each
supported backend runtime type, e.g., Legion, MPI, and HPX
(currently).</p>
<p>The new type must define a <em>set_coloring</em> method that takes the
<em>coloring</em> type defined in assocaited <em>types.h</em> file:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">POLICY_TYPE</span><span class="o">&gt;</span>
<span class="k">struct</span>  <span class="n">topology_instance</span><span class="o">&lt;</span><span class="n">ntree</span><span class="o">&lt;</span><span class="n">POLICY_TYPE</span><span class="o">&gt;&gt;</span> <span class="p">{</span>

  <span class="k">using</span> <span class="n">topology_reference_t</span> <span class="o">=</span>
    <span class="n">topology_reference</span><span class="o">&lt;</span><span class="n">ntree</span><span class="o">&lt;</span><span class="n">POLICY_TYPE</span><span class="o">&gt;&gt;</span><span class="p">;</span>

  <span class="k">static</span> <span class="kt">void</span> <span class="nf">set_coloring</span><span class="p">(</span><span class="n">topology_reference_t</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">topology_reference</span><span class="p">,</span>
    <span class="n">ntree</span><span class="o">&lt;</span><span class="n">POLICY_TYPE</span><span class="o">&gt;::</span><span class="n">coloring</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">colorint</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">}</span> <span class="c1">// set_coloring</span>

<span class="p">};</span> <span class="c1">// topology_instance&lt;ntree&lt;POLICY_TYPE&gt;&gt;</span>
</pre></div>
</div>
</li>
<li><p><strong>Initialize Arguments</strong>: Define a template function
overload of the <em>task_prologue_t</em> type in
<em>flecsi/execution/â¦/task_prologue.h</em> that adds the region
requirements for the given type instance (for Legion only),
updates distributed-memory data dependencies, and
sets a dirty (modified) bit for any fields or topologies that were
accessed with write privileges (write-only, or read-write).</p></li>
<li><p><strong>Bind Accessors</strong>: Define a template function overload of the
<em>bind_accessors_t</em> type in
<em>flecsi/execution/runtime/bind_accessors.h</em>, where
<em>runtime</em> is implmented for each backend runtime. This function binds
backend data buffers into the topology accesor instance. The accessor
is defined as part of the topology type, and implements a
<em>proxy</em> <a class="reference external" href="https://en.wikipedia.org/wiki/Proxy_pattern">pattern</a>.</p></li>
<li><p><strong>Unbind Accessors</strong>: Define a template function overload of the
<em>unbind_accessors_t</em> type in
<em>flecsi/execution/runtime/unbind_accessors.h</em>, where
<em>runtime</em> is implmented for each backend runtime. This function unbinds
backend data buffers, and does any cleanup operations that are
necessary to complete task execution, e.g., committing changes to
sparse or dynamic storage class fields.</p></li>
</ol>
</div>
<div class="section" id="topology-initialization-workflow">
<h1>Topology Initialization Workflow<a class="headerlink" href="#topology-initialization-workflow" title="Permalink to this headline">Â¶</a></h1>
<ol class="arabic simple">
<li><p>User defines specialization policy</p></li>
<li><p>User defines topology type with policy</p></li>
<li><p>Register meta data fields for specialized topology type</p></li>
<li><p>User adds fields to topology-defined index spaces</p></li>
<li><p>User gets topology instance</p></li>
<li><p>User generates coloring and calls set_coloring on instance</p></li>
<li><p>FleCSI creates index spaces and index partitions</p></li>
<li><p>FleCSI invokes task to initialize topology meta data</p></li>
<li><p>User invokes task to initialize field state</p></li>
</ol>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../core-guide.html" class="btn btn-neutral float-right" title="Core Guide" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="data.html" class="btn btn-neutral float-left" title="Data Model" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016 Los Alamos National Laboratory, LLC

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    

  <style>
    /* Contents caption */
    .wy-menu-vertical>p.caption {
      color: #ffffff;
    }

    /* Sidebar header (and topbar for mobile) */
    .wy-side-nav-search, .wy-nav-top {
      background: #e3e2db;
    }
    .wy-side-nav-search>div.version, .wy-nav-top>div.version {
      color: #5f5d5f;
    }

    /* Sidebar */
    .wy-nav-side {
      background: #216897;
      color: #ffffff;
    }
  </style>


</body>
</html>