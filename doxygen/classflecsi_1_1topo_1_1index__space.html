<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" type="image/x-icon" href="flecsi-favicon.ico" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Interface Documentation: flecsi::topo::index_space&lt; T, STORAGE, OWNED, SORTED, F, ID_STORAGE_TYPE, STORAGE_TYPE &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.flecsi.org"><img alt="Logo" height="200" style="margin-top:40px; margin-left:30px; margin-right:10px" src="medium-flecsi.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Interface Documentation<br>
		<span id="projectnumber">Version: 2.-1 (devel)</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceflecsi.html">flecsi</a></li><li class="navelem"><b>topo</b></li><li class="navelem"><a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classflecsi_1_1topo_1_1index__space-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">flecsi::topo::index_space&lt; T, STORAGE, OWNED, SORTED, F, ID_STORAGE_TYPE, STORAGE_TYPE &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__topology.html">Topology Interface</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="index__space_8hh_source.html">index_space.hh</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space_1_1id__range__.html">id_range_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space_1_1iterator__.html">iterator_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space_1_1iterator___3_01S_00_01void_01_4.html">iterator_&lt; S, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space_1_1iterator__base__.html">iterator_base_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator base, const be parameterized with 'T' or 'const T'.  <a href="classflecsi_1_1topo_1_1index__space_1_1iterator__base__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6335bb7fec6f905999eb0bae4df6bcbe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6335bb7fec6f905999eb0bae4df6bcbe"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a6335bb7fec6f905999eb0bae4df6bcbe">id_t</a> = typename std::remove_pointer&lt; T &gt;::type::id_t</td></tr>
<tr class="memdesc:a6335bb7fec6f905999eb0bae4df6bcbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">ID type. <br/></td></tr>
<tr class="separator:a6335bb7fec6f905999eb0bae4df6bcbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c413fcd416167ae5e515338a413f01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98c413fcd416167ae5e515338a413f01"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a98c413fcd416167ae5e515338a413f01">id_storage_t</a> = ID_STORAGE_TYPE&lt; <a class="el" href="classflecsi_1_1topo_1_1index__space.html#a6335bb7fec6f905999eb0bae4df6bcbe">id_t</a> &gt;</td></tr>
<tr class="memdesc:a98c413fcd416167ae5e515338a413f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">ID storage type. <br/></td></tr>
<tr class="separator:a98c413fcd416167ae5e515338a413f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa6c89200d6726c8dfe18866f2c328c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fa6c89200d6726c8dfe18866f2c328c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a5fa6c89200d6726c8dfe18866f2c328c">storage_t</a> = STORAGE_TYPE&lt; T &gt;</td></tr>
<tr class="memdesc:a5fa6c89200d6726c8dfe18866f2c328c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage type. <br/></td></tr>
<tr class="separator:a5fa6c89200d6726c8dfe18866f2c328c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41201f6fc6540343b8731681492e03f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab41201f6fc6540343b8731681492e03f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#ab41201f6fc6540343b8731681492e03f">item_t</a> = typename std::remove_pointer&lt; T &gt;::type</td></tr>
<tr class="memdesc:ab41201f6fc6540343b8731681492e03f"><td class="mdescLeft">&#160;</td><td class="mdescRight">item, e.g. entity type <br/></td></tr>
<tr class="separator:ab41201f6fc6540343b8731681492e03f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47654d4a8aa0527c25cfcdf1c3ae819"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab47654d4a8aa0527c25cfcdf1c3ae819"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#ab47654d4a8aa0527c25cfcdf1c3ae819">ref_t</a> = typename <a class="el" href="structflecsi_1_1topo_1_1index__space__ref__type.html">index_space_ref_type</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:ab47654d4a8aa0527c25cfcdf1c3ae819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference type. <br/></td></tr>
<tr class="separator:ab47654d4a8aa0527c25cfcdf1c3ae819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adefca08bc845ac979be4cb453f65b227"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adefca08bc845ac979be4cb453f65b227"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#adefca08bc845ac979be4cb453f65b227">cast_t</a> = std::decay_t&lt; <a class="el" href="classflecsi_1_1topo_1_1index__space.html#ab47654d4a8aa0527c25cfcdf1c3ae819">ref_t</a> &gt;</td></tr>
<tr class="memdesc:adefca08bc845ac979be4cb453f65b227"><td class="mdescLeft">&#160;</td><td class="mdescRight">reference casting type <br/></td></tr>
<tr class="separator:adefca08bc845ac979be4cb453f65b227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959541349f8d2fa3f3c9ff5f0b38b15e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a959541349f8d2fa3f3c9ff5f0b38b15e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a959541349f8d2fa3f3c9ff5f0b38b15e">apply_function</a> = std::function&lt; void(T &amp;)&gt;</td></tr>
<tr class="memdesc:a959541349f8d2fa3f3c9ff5f0b38b15e"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply function signature <br/></td></tr>
<tr class="separator:a959541349f8d2fa3f3c9ff5f0b38b15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f8ce4670129d53d691c0fb8428112c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a88f8ce4670129d53d691c0fb8428112c"></a>
template&lt;typename S &gt; </td></tr>
<tr class="memitem:a88f8ce4670129d53d691c0fb8428112c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a88f8ce4670129d53d691c0fb8428112c">map_function</a> = std::function&lt; S(T &amp;)&gt;</td></tr>
<tr class="memdesc:a88f8ce4670129d53d691c0fb8428112c"><td class="mdescLeft">&#160;</td><td class="mdescRight">map function signature <br/></td></tr>
<tr class="separator:a88f8ce4670129d53d691c0fb8428112c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca0aa21f1184a417e90d80c3b34edd8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7ca0aa21f1184a417e90d80c3b34edd8"></a>
template&lt;typename S &gt; </td></tr>
<tr class="memitem:a7ca0aa21f1184a417e90d80c3b34edd8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a7ca0aa21f1184a417e90d80c3b34edd8">reduce_function</a> = std::function&lt; void(T &amp;, S &amp;)&gt;</td></tr>
<tr class="memdesc:a7ca0aa21f1184a417e90d80c3b34edd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce function signature. <br/></td></tr>
<tr class="separator:a7ca0aa21f1184a417e90d80c3b34edd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adbf255a974b96fc76c0f09302a73edff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#adbf255a974b96fc76c0f09302a73edff">index_space</a> (bool <a class="el" href="classflecsi_1_1topo_1_1index__space.html#a179532fb1046248d977ffe4ecc56bcd5">storage</a>=STORAGE)</td></tr>
<tr class="separator:adbf255a974b96fc76c0f09302a73edff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbef23dc7ef3498bdf7ba49d68deae86"><td class="memTemplParams" colspan="2">template&lt;class S , bool STORAGE2, bool OWNED2, bool SORTED2, class F2 , template&lt; typename, typename...&gt; class ID_STORAGE_TYPE2, template&lt; typename, typename...&gt; class STORAGE_TYPE2&gt; </td></tr>
<tr class="memitem:abbef23dc7ef3498bdf7ba49d68deae86"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#abbef23dc7ef3498bdf7ba49d68deae86">index_space</a> (const <a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a>&lt; S, STORAGE2, OWNED2, SORTED2, F2, ID_STORAGE_TYPE2, STORAGE_TYPE2 &gt; &amp;is, size_t <a class="el" href="classflecsi_1_1topo_1_1index__space.html#aa1aaac13ed82c42b2079cf131bab41ec">begin</a>, size_t <a class="el" href="classflecsi_1_1topo_1_1index__space.html#ad286ae946a3728a071d54f6627117cd2">end</a>)</td></tr>
<tr class="separator:abbef23dc7ef3498bdf7ba49d68deae86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2891450b4198ff3cb2a4e6a0b537567"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2891450b4198ff3cb2a4e6a0b537567"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#ac2891450b4198ff3cb2a4e6a0b537567">index_space</a> (const <a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a> &amp;is)</td></tr>
<tr class="memdesc:ac2891450b4198ff3cb2a4e6a0b537567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor to alias an existing index space unless OWNED. <br/></td></tr>
<tr class="separator:ac2891450b4198ff3cb2a4e6a0b537567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064edd786bcb3eb65ab60fe42d541f25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a064edd786bcb3eb65ab60fe42d541f25"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a064edd786bcb3eb65ab60fe42d541f25">index_space</a> (<a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a> &amp;&amp;is)</td></tr>
<tr class="memdesc:a064edd786bcb3eb65ab60fe42d541f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br/></td></tr>
<tr class="separator:a064edd786bcb3eb65ab60fe42d541f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337cc443040612317396cf060d0bc2f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a337cc443040612317396cf060d0bc2f9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a337cc443040612317396cf060d0bc2f9">~index_space</a> ()</td></tr>
<tr class="memdesc:a337cc443040612317396cf060d0bc2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:a337cc443040612317396cf060d0bc2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179532fb1046248d977ffe4ecc56bcd5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a179532fb1046248d977ffe4ecc56bcd5"></a>
<a class="el" href="classflecsi_1_1topo_1_1index__space.html#a5fa6c89200d6726c8dfe18866f2c328c">storage_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a179532fb1046248d977ffe4ecc56bcd5">storage</a> ()</td></tr>
<tr class="memdesc:a179532fb1046248d977ffe4ecc56bcd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the storage object. <br/></td></tr>
<tr class="separator:a179532fb1046248d977ffe4ecc56bcd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb8df0e8a96b7a4e1492fedeb01db19"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0fb8df0e8a96b7a4e1492fedeb01db19"></a>
const <a class="el" href="classflecsi_1_1topo_1_1index__space.html#a5fa6c89200d6726c8dfe18866f2c328c">storage_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a0fb8df0e8a96b7a4e1492fedeb01db19">storage</a> () const </td></tr>
<tr class="memdesc:a0fb8df0e8a96b7a4e1492fedeb01db19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the storage object. <br/></td></tr>
<tr class="separator:a0fb8df0e8a96b7a4e1492fedeb01db19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab107bd3d8eb180f0640595fedc5abb0a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab107bd3d8eb180f0640595fedc5abb0a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#ab107bd3d8eb180f0640595fedc5abb0a">set_storage</a> (<a class="el" href="classflecsi_1_1topo_1_1index__space.html#a5fa6c89200d6726c8dfe18866f2c328c">storage_t</a> *s)</td></tr>
<tr class="memdesc:ab107bd3d8eb180f0640595fedc5abb0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the storage object. <br/></td></tr>
<tr class="separator:ab107bd3d8eb180f0640595fedc5abb0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dcc3cd7d0589ad76bf5da61992ebd1d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5dcc3cd7d0589ad76bf5da61992ebd1d"></a>
<a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a5dcc3cd7d0589ad76bf5da61992ebd1d">operator=</a> (const <a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a> &amp;is)</td></tr>
<tr class="memdesc:a5dcc3cd7d0589ad76bf5da61992ebd1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. Alias an existing index space unless OWNED. <br/></td></tr>
<tr class="separator:a5dcc3cd7d0589ad76bf5da61992ebd1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9497b16d8cd0a6eb9d914c1b8494ee5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9497b16d8cd0a6eb9d914c1b8494ee5"></a>
<a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#ac9497b16d8cd0a6eb9d914c1b8494ee5">operator=</a> (<a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a> &amp;&amp;is)</td></tr>
<tr class="memdesc:ac9497b16d8cd0a6eb9d914c1b8494ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. <br/></td></tr>
<tr class="separator:ac9497b16d8cd0a6eb9d914c1b8494ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0e62b809a7497b76eb2763b988370e"><td class="memTemplParams" colspan="2">template&lt;class S , bool STORAGE2 = STORAGE, bool OWNED2 = OWNED, bool SORTED2 = SORTED, class F2  = F, template&lt; typename, typename...&gt; class ID_STORAGE_TYPE2 = ID_STORAGE_TYPE, template&lt; typename, typename...&gt; class STORAGE_TYPE2 = STORAGE_TYPE&gt; </td></tr>
<tr class="memitem:a9c0e62b809a7497b76eb2763b988370e"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a9c0e62b809a7497b76eb2763b988370e">cast</a> ()</td></tr>
<tr class="separator:a9c0e62b809a7497b76eb2763b988370e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b9bfa8d8e8f4d3bf6ea23247fafdfe"><td class="memTemplParams" colspan="2">template&lt;class S , bool STORAGE2 = STORAGE, bool OWNED2 = OWNED, bool SORTED2 = SORTED, class F2  = F, template&lt; typename, typename...&gt; class ID_STORAGE_TYPE2 = ID_STORAGE_TYPE, template&lt; typename, typename...&gt; class STORAGE_TYPE2 = STORAGE_TYPE&gt; </td></tr>
<tr class="memitem:aa7b9bfa8d8e8f4d3bf6ea23247fafdfe"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#aa7b9bfa8d8e8f4d3bf6ea23247fafdfe">cast</a> () const </td></tr>
<tr class="separator:aa7b9bfa8d8e8f4d3bf6ea23247fafdfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1aaac13ed82c42b2079cf131bab41ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1aaac13ed82c42b2079cf131bab41ec"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#aa1aaac13ed82c42b2079cf131bab41ec">begin</a> ()</td></tr>
<tr class="memdesc:aa1aaac13ed82c42b2079cf131bab41ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return begin iterator. <br/></td></tr>
<tr class="separator:aa1aaac13ed82c42b2079cf131bab41ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9625a5981318ea6f10bbf2ec8c13d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c9625a5981318ea6f10bbf2ec8c13d1"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a1c9625a5981318ea6f10bbf2ec8c13d1">begin</a> () const </td></tr>
<tr class="memdesc:a1c9625a5981318ea6f10bbf2ec8c13d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return begin iterator. <br/></td></tr>
<tr class="separator:a1c9625a5981318ea6f10bbf2ec8c13d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad286ae946a3728a071d54f6627117cd2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad286ae946a3728a071d54f6627117cd2"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#ad286ae946a3728a071d54f6627117cd2">end</a> ()</td></tr>
<tr class="memdesc:ad286ae946a3728a071d54f6627117cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return end iterator. <br/></td></tr>
<tr class="separator:ad286ae946a3728a071d54f6627117cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64179c4bdab0e4708e63f174823b1905"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64179c4bdab0e4708e63f174823b1905"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a64179c4bdab0e4708e63f174823b1905">end</a> () const </td></tr>
<tr class="memdesc:a64179c4bdab0e4708e63f174823b1905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return end iterator. <br/></td></tr>
<tr class="separator:a64179c4bdab0e4708e63f174823b1905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1edee17f1f7514f85521cef8a3976ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1edee17f1f7514f85521cef8a3976ab"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#aa1edee17f1f7514f85521cef8a3976ab">begin_offset</a> () const </td></tr>
<tr class="memdesc:aa1edee17f1f7514f85521cef8a3976ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return begin offset. <br/></td></tr>
<tr class="separator:aa1edee17f1f7514f85521cef8a3976ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd103e7e6d5b754f794ae010e9174015"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd103e7e6d5b754f794ae010e9174015"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#abd103e7e6d5b754f794ae010e9174015">end_offset</a> () const </td></tr>
<tr class="memdesc:abd103e7e6d5b754f794ae010e9174015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return end offset. <br/></td></tr>
<tr class="separator:abd103e7e6d5b754f794ae010e9174015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b809aad345f1f2c233df7209d2ee54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5b809aad345f1f2c233df7209d2ee54"></a>
<a class="el" href="classflecsi_1_1topo_1_1index__space.html#ab47654d4a8aa0527c25cfcdf1c3ae819">ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#ab5b809aad345f1f2c233df7209d2ee54">get_offset</a> (size_t offset)</td></tr>
<tr class="memdesc:ab5b809aad345f1f2c233df7209d2ee54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get offset. <br/></td></tr>
<tr class="separator:ab5b809aad345f1f2c233df7209d2ee54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb806181dca4c9f7e62a8587e5530b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aabb806181dca4c9f7e62a8587e5530b2"></a>
const <a class="el" href="classflecsi_1_1topo_1_1index__space.html#ab47654d4a8aa0527c25cfcdf1c3ae819">ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#aabb806181dca4c9f7e62a8587e5530b2">get_offset</a> (size_t offset) const </td></tr>
<tr class="memdesc:aabb806181dca4c9f7e62a8587e5530b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get offset. <br/></td></tr>
<tr class="separator:aabb806181dca4c9f7e62a8587e5530b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc54c1742b07d05e2455dc73ba8af31"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8cc54c1742b07d05e2455dc73ba8af31"></a>
<a class="el" href="classflecsi_1_1topo_1_1index__space_1_1id__range__.html">id_range_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a8cc54c1742b07d05e2455dc73ba8af31">ids</a> () const </td></tr>
<tr class="memdesc:a8cc54c1742b07d05e2455dc73ba8af31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all IDs in range. <br/></td></tr>
<tr class="separator:a8cc54c1742b07d05e2455dc73ba8af31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884b9ad65ea629385aaf43605dc95e42"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a884b9ad65ea629385aaf43605dc95e42"></a>
<a class="el" href="classflecsi_1_1topo_1_1index__space_1_1id__range__.html">id_range_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a884b9ad65ea629385aaf43605dc95e42">ids</a> (size_t <a class="el" href="classflecsi_1_1topo_1_1index__space.html#aa1aaac13ed82c42b2079cf131bab41ec">begin</a>, size_t <a class="el" href="classflecsi_1_1topo_1_1index__space.html#ad286ae946a3728a071d54f6627117cd2">end</a>) const </td></tr>
<tr class="memdesc:a884b9ad65ea629385aaf43605dc95e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all IDs in range. <br/></td></tr>
<tr class="separator:a884b9ad65ea629385aaf43605dc95e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d531784b78aa279078e757d5919a6c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1d531784b78aa279078e757d5919a6c"></a>
<a class="el" href="classflecsi_1_1topo_1_1index__space_1_1id__range__.html">id_range_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#ab1d531784b78aa279078e757d5919a6c">ids</a> (const std::pair&lt; size_t, size_t &gt; &amp;p) const </td></tr>
<tr class="memdesc:ab1d531784b78aa279078e757d5919a6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all IDs in range. <br/></td></tr>
<tr class="separator:ab1d531784b78aa279078e757d5919a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6078614baf787bb009502cd5975ef0e6"><td class="memTemplParams" colspan="2">template&lt;class S  = T&gt; </td></tr>
<tr class="memitem:a6078614baf787bb009502cd5975ef0e6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a6078614baf787bb009502cd5975ef0e6">slice</a> (size_t <a class="el" href="classflecsi_1_1topo_1_1index__space.html#aa1aaac13ed82c42b2079cf131bab41ec">begin</a>, size_t <a class="el" href="classflecsi_1_1topo_1_1index__space.html#ad286ae946a3728a071d54f6627117cd2">end</a>) const </td></tr>
<tr class="separator:a6078614baf787bb009502cd5975ef0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4babfc0b224fde50f1ad9484f4275e89"><td class="memTemplParams" colspan="2">template&lt;class S  = T&gt; </td></tr>
<tr class="memitem:a4babfc0b224fde50f1ad9484f4275e89"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a4babfc0b224fde50f1ad9484f4275e89">slice</a> (const std::pair&lt; size_t, size_t &gt; &amp;range) const </td></tr>
<tr class="separator:a4babfc0b224fde50f1ad9484f4275e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b551e65bc8aefafeef561b2b8762db0"><td class="memTemplParams" colspan="2">template&lt;class S  = T&gt; </td></tr>
<tr class="memitem:a0b551e65bc8aefafeef561b2b8762db0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a0b551e65bc8aefafeef561b2b8762db0">slice</a> () const </td></tr>
<tr class="separator:a0b551e65bc8aefafeef561b2b8762db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f65985aa72d49bf1e6ff613ee9200b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32f65985aa72d49bf1e6ff613ee9200b"></a>
<a class="el" href="classflecsi_1_1topo_1_1index__space.html#ab47654d4a8aa0527c25cfcdf1c3ae819">ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a32f65985aa72d49bf1e6ff613ee9200b">get_</a> (size_t offset)</td></tr>
<tr class="memdesc:a32f65985aa72d49bf1e6ff613ee9200b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method. Get item at offset. <br/></td></tr>
<tr class="separator:a32f65985aa72d49bf1e6ff613ee9200b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088005735fa104f8b0df41aca25f1225"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a088005735fa104f8b0df41aca25f1225"></a>
const <a class="el" href="classflecsi_1_1topo_1_1index__space.html#ab47654d4a8aa0527c25cfcdf1c3ae819">ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a088005735fa104f8b0df41aca25f1225">get_</a> (size_t offset) const </td></tr>
<tr class="memdesc:a088005735fa104f8b0df41aca25f1225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method. Get item at offset. <br/></td></tr>
<tr class="separator:a088005735fa104f8b0df41aca25f1225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11f1be5af4a33d2611dfe354c95f24f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa11f1be5af4a33d2611dfe354c95f24f"></a>
<a class="el" href="classflecsi_1_1topo_1_1index__space.html#ab47654d4a8aa0527c25cfcdf1c3ae819">ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#aa11f1be5af4a33d2611dfe354c95f24f">get_end_</a> (size_t offset)</td></tr>
<tr class="memdesc:aa11f1be5af4a33d2611dfe354c95f24f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method. Get item at offset from end. <br/></td></tr>
<tr class="separator:aa11f1be5af4a33d2611dfe354c95f24f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8297bc68a951b1804889a676eb3672"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f8297bc68a951b1804889a676eb3672"></a>
const <a class="el" href="classflecsi_1_1topo_1_1index__space.html#ab47654d4a8aa0527c25cfcdf1c3ae819">ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a8f8297bc68a951b1804889a676eb3672">get_end_</a> (size_t offset) const </td></tr>
<tr class="memdesc:a8f8297bc68a951b1804889a676eb3672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method. Get item at offset from end. <br/></td></tr>
<tr class="separator:a8f8297bc68a951b1804889a676eb3672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a126e30af1b47eac122540513d834df8f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a126e30af1b47eac122540513d834df8f"></a>
<a class="el" href="classflecsi_1_1topo_1_1index__space.html#ab47654d4a8aa0527c25cfcdf1c3ae819">ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a126e30af1b47eac122540513d834df8f">operator[]</a> (size_t offset)</td></tr>
<tr class="memdesc:a126e30af1b47eac122540513d834df8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get item at offset. <br/></td></tr>
<tr class="separator:a126e30af1b47eac122540513d834df8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a7c9a63d35f64c795360db499ce77d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49a7c9a63d35f64c795360db499ce77d"></a>
const <a class="el" href="classflecsi_1_1topo_1_1index__space.html#ab47654d4a8aa0527c25cfcdf1c3ae819">ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a49a7c9a63d35f64c795360db499ce77d">operator[]</a> (size_t i) const </td></tr>
<tr class="memdesc:a49a7c9a63d35f64c795360db499ce77d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get item at offset. <br/></td></tr>
<tr class="separator:a49a7c9a63d35f64c795360db499ce77d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee51debd9c93e0b7804a360cab409c9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classflecsi_1_1topo_1_1index__space.html#a6335bb7fec6f905999eb0bae4df6bcbe">id_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#adee51debd9c93e0b7804a360cab409c9">operator()</a> (size_t i) const </td></tr>
<tr class="separator:adee51debd9c93e0b7804a360cab409c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23034508aa0245052cf33c35506e6cf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a6335bb7fec6f905999eb0bae4df6bcbe">id_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a23034508aa0245052cf33c35506e6cf8">operator()</a> (size_t i)</td></tr>
<tr class="separator:a23034508aa0245052cf33c35506e6cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15de455b45b1bb94f6fd92734838c980"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15de455b45b1bb94f6fd92734838c980"></a>
<a class="el" href="classflecsi_1_1topo_1_1index__space.html#ab47654d4a8aa0527c25cfcdf1c3ae819">ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a15de455b45b1bb94f6fd92734838c980">front</a> ()</td></tr>
<tr class="memdesc:a15de455b45b1bb94f6fd92734838c980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the entity at the front of the index space. <br/></td></tr>
<tr class="separator:a15de455b45b1bb94f6fd92734838c980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae803d1a5932657fc69825775ea0ea2f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae803d1a5932657fc69825775ea0ea2f1"></a>
const <a class="el" href="classflecsi_1_1topo_1_1index__space.html#ab47654d4a8aa0527c25cfcdf1c3ae819">ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#ae803d1a5932657fc69825775ea0ea2f1">front</a> () const </td></tr>
<tr class="memdesc:ae803d1a5932657fc69825775ea0ea2f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the entity at the front of the index space. <br/></td></tr>
<tr class="separator:ae803d1a5932657fc69825775ea0ea2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8646b8123987d00a759c1fa281673b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff8646b8123987d00a759c1fa281673b"></a>
<a class="el" href="classflecsi_1_1topo_1_1index__space.html#ab47654d4a8aa0527c25cfcdf1c3ae819">ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#aff8646b8123987d00a759c1fa281673b">back</a> ()</td></tr>
<tr class="memdesc:aff8646b8123987d00a759c1fa281673b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the entity at the back of the index space. <br/></td></tr>
<tr class="separator:aff8646b8123987d00a759c1fa281673b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf677122412f4f86e2b0df95d26a1287"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf677122412f4f86e2b0df95d26a1287"></a>
const <a class="el" href="classflecsi_1_1topo_1_1index__space.html#ab47654d4a8aa0527c25cfcdf1c3ae819">ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#abf677122412f4f86e2b0df95d26a1287">back</a> () const </td></tr>
<tr class="memdesc:abf677122412f4f86e2b0df95d26a1287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the entity at the back of the index space. <br/></td></tr>
<tr class="separator:abf677122412f4f86e2b0df95d26a1287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e0209e6f592be27e844c4b9a1f9f2c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61e0209e6f592be27e844c4b9a1f9f2c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a61e0209e6f592be27e844c4b9a1f9f2c">size</a> () const </td></tr>
<tr class="memdesc:a61e0209e6f592be27e844c4b9a1f9f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the index space. <br/></td></tr>
<tr class="separator:a61e0209e6f592be27e844c4b9a1f9f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe34bf00fde1e40aa712361385c137c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbe34bf00fde1e40aa712361385c137c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#adbe34bf00fde1e40aa712361385c137c">empty</a> () const </td></tr>
<tr class="memdesc:adbe34bf00fde1e40aa712361385c137c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return if the index space is empty, i.e. has no indices. <br/></td></tr>
<tr class="separator:adbe34bf00fde1e40aa712361385c137c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f0f23691fd234032eacb146b2206624"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f0f23691fd234032eacb146b2206624"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a4f0f23691fd234032eacb146b2206624">clear</a> ()</td></tr>
<tr class="memdesc:a4f0f23691fd234032eacb146b2206624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all indices and entities. <br/></td></tr>
<tr class="separator:a4f0f23691fd234032eacb146b2206624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9486ffbecd5b11ac50843ef51a48f134"><td class="memTemplParams" colspan="2">template&lt;bool STORAGE2, bool OWNED2, bool SORTED2, class F2 , template&lt; typename, typename...&gt; class INDEX_STORAGE_TYPE2, template&lt; typename, typename...&gt; class STORAGE_TYPE2&gt; </td></tr>
<tr class="memitem:a9486ffbecd5b11ac50843ef51a48f134"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a9486ffbecd5b11ac50843ef51a48f134">set_master</a> (const <a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a>&lt; T, STORAGE2, OWNED2, SORTED2, F2, INDEX_STORAGE_TYPE2, STORAGE_TYPE2 &gt; &amp;master)</td></tr>
<tr class="separator:a9486ffbecd5b11ac50843ef51a48f134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9bca3fcd07b1fa8522ff454069ee3e"><td class="memTemplParams" colspan="2">template&lt;bool STORAGE2, bool OWNED2, bool SORTED2, class F2 , template&lt; typename, typename...&gt; class INDEX_STORAGE_TYPE2, template&lt; typename, typename...&gt; class STORAGE_TYPE2&gt; </td></tr>
<tr class="memitem:a0a9bca3fcd07b1fa8522ff454069ee3e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a0a9bca3fcd07b1fa8522ff454069ee3e">set_master</a> (<a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a>&lt; T, STORAGE2, OWNED2, SORTED2, F2, INDEX_STORAGE_TYPE2, STORAGE_TYPE2 &gt; &amp;master)</td></tr>
<tr class="separator:a0a9bca3fcd07b1fa8522ff454069ee3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf172aec3fa0a8678645e5eb6b96a58d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; const T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#abf172aec3fa0a8678645e5eb6b96a58d">to_vec</a> () const </td></tr>
<tr class="separator:abf172aec3fa0a8678645e5eb6b96a58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4dcbaa7af405989cd2f20929be887e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a9a4dcbaa7af405989cd2f20929be887e">to_vec</a> ()</td></tr>
<tr class="separator:a9a4dcbaa7af405989cd2f20929be887e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711ecab3a70c34df57e69d90933282c5"><td class="memTemplParams" colspan="2">template&lt;class S &gt; </td></tr>
<tr class="memitem:a711ecab3a70c34df57e69d90933282c5"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; S &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a711ecab3a70c34df57e69d90933282c5">to_vec_</a> ()</td></tr>
<tr class="separator:a711ecab3a70c34df57e69d90933282c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3986e2efb6c4cd1e560305e2fbec404d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3986e2efb6c4cd1e560305e2fbec404d"></a>
const <a class="el" href="classflecsi_1_1topo_1_1index__space.html#a98c413fcd416167ae5e515338a413f01">id_storage_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a3986e2efb6c4cd1e560305e2fbec404d">id_storage</a> () const </td></tr>
<tr class="memdesc:a3986e2efb6c4cd1e560305e2fbec404d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index storage object. <br/></td></tr>
<tr class="separator:a3986e2efb6c4cd1e560305e2fbec404d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8fce628687f0d4ea0c2555d3b8d88a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8fce628687f0d4ea0c2555d3b8d88a3"></a>
<a class="el" href="classflecsi_1_1topo_1_1index__space.html#a98c413fcd416167ae5e515338a413f01">id_storage_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#ad8fce628687f0d4ea0c2555d3b8d88a3">id_storage</a> ()</td></tr>
<tr class="memdesc:ad8fce628687f0d4ea0c2555d3b8d88a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index storage object. <br/></td></tr>
<tr class="separator:ad8fce628687f0d4ea0c2555d3b8d88a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f6ad4a6f272f746b39aeb49165ede6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3f6ad4a6f272f746b39aeb49165ede6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#ae3f6ad4a6f272f746b39aeb49165ede6">set_id_storage</a> (<a class="el" href="classflecsi_1_1topo_1_1index__space.html#a98c413fcd416167ae5e515338a413f01">id_storage_t</a> *v)</td></tr>
<tr class="memdesc:ae3f6ad4a6f272f746b39aeb49165ede6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the index storage object. <br/></td></tr>
<tr class="separator:ae3f6ad4a6f272f746b39aeb49165ede6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32b50db20ad8a4c60efeff6c832077f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae32b50db20ad8a4c60efeff6c832077f"></a>
const <a class="el" href="classflecsi_1_1topo_1_1index__space.html#a6335bb7fec6f905999eb0bae4df6bcbe">id_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#ae32b50db20ad8a4c60efeff6c832077f">id_array</a> () const </td></tr>
<tr class="memdesc:ae32b50db20ad8a4c60efeff6c832077f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index space IDs as an array. <br/></td></tr>
<tr class="separator:ae32b50db20ad8a4c60efeff6c832077f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b8ba9e7f1ac212ccb4ad1158f32ec0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7b8ba9e7f1ac212ccb4ad1158f32ec0"></a>
<a class="el" href="classflecsi_1_1topo_1_1index__space.html#a6335bb7fec6f905999eb0bae4df6bcbe">id_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>id_array</b> ()</td></tr>
<tr class="separator:ae7b8ba9e7f1ac212ccb4ad1158f32ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75ce8c963afc6894bafa82c658bbe43"><td class="memTemplParams" colspan="2">template&lt;typename Predicate &gt; </td></tr>
<tr class="memitem:ab75ce8c963afc6894bafa82c658bbe43"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#ab75ce8c963afc6894bafa82c658bbe43">filter</a> (Predicate &amp;&amp;f) const </td></tr>
<tr class="separator:ab75ce8c963afc6894bafa82c658bbe43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeef26466c3b7d5cf0b787f432ca5b8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#afeef26466c3b7d5cf0b787f432ca5b8e">apply</a> (<a class="el" href="classflecsi_1_1topo_1_1index__space.html#a959541349f8d2fa3f3c9ff5f0b38b15e">apply_function</a> f) const </td></tr>
<tr class="separator:afeef26466c3b7d5cf0b787f432ca5b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b3bb7afbba3c7570cff0b54ce0e366"><td class="memTemplParams" colspan="2">template&lt;class S &gt; </td></tr>
<tr class="memitem:ac5b3bb7afbba3c7570cff0b54ce0e366"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#ac5b3bb7afbba3c7570cff0b54ce0e366">map</a> (<a class="el" href="classflecsi_1_1topo_1_1index__space.html#a88f8ce4670129d53d691c0fb8428112c">map_function</a>&lt; S &gt; f) const </td></tr>
<tr class="separator:ac5b3bb7afbba3c7570cff0b54ce0e366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeedddbb085ae005c75a8f2d32dbefeb1"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:aeedddbb085ae005c75a8f2d32dbefeb1"><td class="memTemplItemLeft" align="right" valign="top">S&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#aeedddbb085ae005c75a8f2d32dbefeb1">reduce</a> (T <a class="el" href="namespaceflecsi.html#a807a7550dece2dd889efa3e5ceb9763d">start</a>, <a class="el" href="classflecsi_1_1topo_1_1index__space.html#a7ca0aa21f1184a417e90d80c3b34edd8">reduce_function</a>&lt; T &gt; f) const </td></tr>
<tr class="separator:aeedddbb085ae005c75a8f2d32dbefeb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94cbee50d03c4a526953ab6f9ef90f60"><td class="memTemplParams" colspan="2">template&lt;typename Predicate &gt; </td></tr>
<tr class="memitem:a94cbee50d03c4a526953ab6f9ef90f60"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a94cbee50d03c4a526953ab6f9ef90f60">bin</a> (Predicate &amp;&amp;f) const </td></tr>
<tr class="memdesc:a94cbee50d03c4a526953ab6f9ef90f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bin entities using a predicate function.  <a href="#a94cbee50d03c4a526953ab6f9ef90f60">More...</a><br/></td></tr>
<tr class="separator:a94cbee50d03c4a526953ab6f9ef90f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaddc6597812ba0610b903a8b5f10a07a"><td class="memTemplParams" colspan="2">template&lt;typename Predicate &gt; </td></tr>
<tr class="memitem:aaddc6597812ba0610b903a8b5f10a07a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#aaddc6597812ba0610b903a8b5f10a07a">bin_as_map</a> (Predicate &amp;&amp;f) const </td></tr>
<tr class="memdesc:aaddc6597812ba0610b903a8b5f10a07a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bin entities using a predicate function.  <a href="#aaddc6597812ba0610b903a8b5f10a07a">More...</a><br/></td></tr>
<tr class="separator:aaddc6597812ba0610b903a8b5f10a07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7e3237cc854d794461ba34a320e208"><td class="memTemplParams" colspan="2">template&lt;typename Predicate &gt; </td></tr>
<tr class="memitem:afb7e3237cc854d794461ba34a320e208"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#afb7e3237cc854d794461ba34a320e208">bin_as_vector</a> (Predicate &amp;&amp;f) const </td></tr>
<tr class="memdesc:afb7e3237cc854d794461ba34a320e208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bin entities using a predicate function.  <a href="#afb7e3237cc854d794461ba34a320e208">More...</a><br/></td></tr>
<tr class="separator:afb7e3237cc854d794461ba34a320e208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd0e5f852ed4112c40c2ee02461855d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a7cd0e5f852ed4112c40c2ee02461855d">prepare_</a> ()</td></tr>
<tr class="separator:a7cd0e5f852ed4112c40c2ee02461855d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1998e93a7aa9dcde6f18b307b17c30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#acc1998e93a7aa9dcde6f18b307b17c30">operator&amp;=</a> (const <a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a> &amp;r)</td></tr>
<tr class="separator:acc1998e93a7aa9dcde6f18b307b17c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4567843d9541a939cb48ebd820310c8f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4567843d9541a939cb48ebd820310c8f"></a>
<a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a4567843d9541a939cb48ebd820310c8f">operator&amp;</a> (const <a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a> &amp;r) const </td></tr>
<tr class="memdesc:a4567843d9541a939cb48ebd820310c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return r-value of set intersection of passed index spaces. <br/></td></tr>
<tr class="separator:a4567843d9541a939cb48ebd820310c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915a6d81eb6c1a81f2f24364655af10c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a915a6d81eb6c1a81f2f24364655af10c">operator|=</a> (const <a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a> &amp;r)</td></tr>
<tr class="separator:a915a6d81eb6c1a81f2f24364655af10c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af586726032a6b2fb8bea3f05a543ebb4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af586726032a6b2fb8bea3f05a543ebb4"></a>
<a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#af586726032a6b2fb8bea3f05a543ebb4">operator|</a> (const <a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a> &amp;r) const </td></tr>
<tr class="memdesc:af586726032a6b2fb8bea3f05a543ebb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return r-value of set union of passed index spaces. <br/></td></tr>
<tr class="separator:af586726032a6b2fb8bea3f05a543ebb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178825c36c13b9e2076db0faff7026ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a178825c36c13b9e2076db0faff7026ca">operator-=</a> (const <a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a> &amp;r)</td></tr>
<tr class="separator:a178825c36c13b9e2076db0faff7026ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159375af41dad7ed4ab0d36b52dbff60"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a159375af41dad7ed4ab0d36b52dbff60"></a>
<a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a159375af41dad7ed4ab0d36b52dbff60">operator-</a> (const <a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a> &amp;r) const </td></tr>
<tr class="memdesc:a159375af41dad7ed4ab0d36b52dbff60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return r-value of set difference of passed index spaces. <br/></td></tr>
<tr class="separator:a159375af41dad7ed4ab0d36b52dbff60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668d5f6196b41b99bf0521eb4d20928c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a668d5f6196b41b99bf0521eb4d20928c">push_back</a> (const T &amp;item)</td></tr>
<tr class="separator:a668d5f6196b41b99bf0521eb4d20928c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2443937221dd64f620f11a48461dc3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#af2443937221dd64f620f11a48461dc3d">push_back</a> (<a class="el" href="classflecsi_1_1topo_1_1index__space.html#a6335bb7fec6f905999eb0bae4df6bcbe">id_t</a> <a class="el" href="structflecsi_1_1topo_1_1index.html">index</a>)</td></tr>
<tr class="separator:af2443937221dd64f620f11a48461dc3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2ed41f367dd1ebe2ea9d818fdea96c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b2ed41f367dd1ebe2ea9d818fdea96c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a1b2ed41f367dd1ebe2ea9d818fdea96c">pushed</a> ()</td></tr>
<tr class="memdesc:a1b2ed41f367dd1ebe2ea9d818fdea96c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called if an index was added to storage internally. <br/></td></tr>
<tr class="separator:a1b2ed41f367dd1ebe2ea9d818fdea96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa103257ddd962fbeb6087dc82b7f10c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#aa103257ddd962fbeb6087dc82b7f10c3">append</a> (const <a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a> &amp;is)</td></tr>
<tr class="separator:aa103257ddd962fbeb6087dc82b7f10c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae438103175e4dc16f684e55cd2904d6e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae438103175e4dc16f684e55cd2904d6e"></a>
<a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#ae438103175e4dc16f684e55cd2904d6e">operator&lt;&lt;</a> (T item)</td></tr>
<tr class="memdesc:ae438103175e4dc16f684e55cd2904d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut for <a class="el" href="classflecsi_1_1topo_1_1index__space.html#a668d5f6196b41b99bf0521eb4d20928c">push_back()</a> <br/></td></tr>
<tr class="separator:ae438103175e4dc16f684e55cd2904d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade30b5555b4d372544ba852e1fc78675"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade30b5555b4d372544ba852e1fc78675"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#ade30b5555b4d372544ba852e1fc78675">append_</a> (const std::vector&lt; T &gt; &amp;ents, const std::vector&lt; <a class="el" href="classflecsi_1_1topo_1_1index__space.html#a6335bb7fec6f905999eb0bae4df6bcbe">id_t</a> &gt; &amp;<a class="el" href="classflecsi_1_1topo_1_1index__space.html#a8cc54c1742b07d05e2455dc73ba8af31">ids</a>)</td></tr>
<tr class="memdesc:ade30b5555b4d372544ba852e1fc78675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append helper method. Do not call directly. <br/></td></tr>
<tr class="separator:ade30b5555b4d372544ba852e1fc78675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed0a94bf903732659e40eedf01b86ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afed0a94bf903732659e40eedf01b86ee"></a>
<a class="el" href="classflecsi_1_1topo_1_1index__space.html#a6335bb7fec6f905999eb0bae4df6bcbe">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#afed0a94bf903732659e40eedf01b86ee">id_</a> (const <a class="el" href="classflecsi_1_1topo_1_1index__space.html#ab41201f6fc6540343b8731681492e03f">item_t</a> &amp;item)</td></tr>
<tr class="memdesc:afed0a94bf903732659e40eedf01b86ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to get ID. <br/></td></tr>
<tr class="separator:afed0a94bf903732659e40eedf01b86ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947598f1f7dfe2f8e34aa486005105c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a947598f1f7dfe2f8e34aa486005105c7"></a>
<a class="el" href="classflecsi_1_1topo_1_1index__space.html#a6335bb7fec6f905999eb0bae4df6bcbe">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a947598f1f7dfe2f8e34aa486005105c7">id_</a> (const <a class="el" href="classflecsi_1_1topo_1_1index__space.html#ab41201f6fc6540343b8731681492e03f">item_t</a> *item)</td></tr>
<tr class="memdesc:a947598f1f7dfe2f8e34aa486005105c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to get ID. <br/></td></tr>
<tr class="separator:a947598f1f7dfe2f8e34aa486005105c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b06864af717e16c75eaf8befa01300"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57b06864af717e16c75eaf8befa01300"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a57b06864af717e16c75eaf8befa01300">set_begin</a> (size_t <a class="el" href="classflecsi_1_1topo_1_1index__space.html#aa1aaac13ed82c42b2079cf131bab41ec">begin</a>)</td></tr>
<tr class="memdesc:a57b06864af717e16c75eaf8befa01300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to begin index of contained IDs. <br/></td></tr>
<tr class="separator:a57b06864af717e16c75eaf8befa01300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92695637a56e46892fc87119555d91f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92695637a56e46892fc87119555d91f7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a92695637a56e46892fc87119555d91f7">set_end</a> (size_t <a class="el" href="classflecsi_1_1topo_1_1index__space.html#ad286ae946a3728a071d54f6627117cd2">end</a>)</td></tr>
<tr class="memdesc:a92695637a56e46892fc87119555d91f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the end index of contained IDs. <br/></td></tr>
<tr class="separator:a92695637a56e46892fc87119555d91f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a16b1d095946cf03f177cf2ded4d11670"><td class="memTemplParams" colspan="2"><a class="anchor" id="a16b1d095946cf03f177cf2ded4d11670"></a>
template&lt;class , bool , bool , bool , class , template&lt; class, class...&gt; class, template&lt; class, class...&gt; class&gt; </td></tr>
<tr class="memitem:a16b1d095946cf03f177cf2ded4d11670"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>index_space</b></td></tr>
<tr class="separator:a16b1d095946cf03f177cf2ded4d11670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8dbd4836578622362ab6ddeb20c08f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade8dbd4836578622362ab6ddeb20c08f"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>connectivity_t</b></td></tr>
<tr class="separator:ade8dbd4836578622362ab6ddeb20c08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, bool STORAGE = false, bool OWNED = true, bool SORTED = false, class F = void, template&lt; typename, typename...&gt; class ID_STORAGE_TYPE = std::vector, template&lt; typename, typename...&gt; class STORAGE_TYPE = ID_STORAGE_TYPE&gt;<br/>
class flecsi::topo::index_space&lt; T, STORAGE, OWNED, SORTED, F, ID_STORAGE_TYPE, STORAGE_TYPE &gt;</h3>

<p><a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a> provides a compile-time configurable and iterable container of objects, e.g. mesh/tree topology entities and their id's. Index space defines the concept of STORAGE - whether the actual entities referenced are stored within this index space OR contained in a 'master' index space. OWNERSHIP - whether its set of id's are owned by this index space or aliased to another index space and then must be copied before this index space can then modify them. SORTED - refers to if the id's are sorted and can then have set operations directly applied to them, else the index space must first be sorted. To make operations on index spaces faster, the index space is parameterized on a number of these parameters and can be efficiently recast depending on how it is to be used.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">STORAGE</td><td>if true then this is a 'master' index space with its own storage.</td></tr>
    <tr><td class="paramname">OWNED</td><td>if true then id ownership is definitely true, else must check owned_ at runtime</td></tr>
    <tr><td class="paramname">SORTED</td><td>if true then id's are definitely sorted and shall be maintained in sorted order.</td></tr>
    <tr><td class="paramname">F</td><td>iterator predicate/filter function </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="adbf255a974b96fc76c0f09302a73edff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool STORAGE = false, bool OWNED = true, bool SORTED = false, class F = void, template&lt; typename, typename...&gt; class ID_STORAGE_TYPE = std::vector, template&lt; typename, typename...&gt; class STORAGE_TYPE = ID_STORAGE_TYPE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflecsi_1_1topo_1_1index__space.html">flecsi::topo::index_space</a>&lt; T, STORAGE, OWNED, SORTED, F, ID_STORAGE_TYPE, STORAGE_TYPE &gt;::<a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>storage</em> = <code>STORAGE</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor. If storage is true then allocate storage type, else this index space will index into a separate storage. </p>

</div>
</div>
<a class="anchor" id="abbef23dc7ef3498bdf7ba49d68deae86"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool STORAGE = false, bool OWNED = true, bool SORTED = false, class F = void, template&lt; typename, typename...&gt; class ID_STORAGE_TYPE = std::vector, template&lt; typename, typename...&gt; class STORAGE_TYPE = ID_STORAGE_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class S , bool STORAGE2, bool OWNED2, bool SORTED2, class F2 , template&lt; typename, typename...&gt; class ID_STORAGE_TYPE2, template&lt; typename, typename...&gt; class STORAGE_TYPE2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflecsi_1_1topo_1_1index__space.html">flecsi::topo::index_space</a>&lt; T, STORAGE, OWNED, SORTED, F, ID_STORAGE_TYPE, STORAGE_TYPE &gt;::<a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a>&lt; S, STORAGE2, OWNED2, SORTED2, F2, ID_STORAGE_TYPE2, STORAGE_TYPE2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Slice constructor. A slice is a view on existing index space and narrower range. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa103257ddd962fbeb6087dc82b7f10c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool STORAGE = false, bool OWNED = true, bool SORTED = false, class F = void, template&lt; typename, typename...&gt; class ID_STORAGE_TYPE = std::vector, template&lt; typename, typename...&gt; class STORAGE_TYPE = ID_STORAGE_TYPE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflecsi_1_1topo_1_1index__space.html">flecsi::topo::index_space</a>&lt; T, STORAGE, OWNED, SORTED, F, ID_STORAGE_TYPE, STORAGE_TYPE &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a>&lt; T, STORAGE, OWNED, SORTED, F, ID_STORAGE_TYPE, STORAGE_TYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Append another index space's entities to the index space. If the index space does not have storage then only the indices are appended. It will create a copy of its aliased indices if OWNED is false. </p>

</div>
</div>
<a class="anchor" id="afeef26466c3b7d5cf0b787f432ca5b8e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool STORAGE = false, bool OWNED = true, bool SORTED = false, class F = void, template&lt; typename, typename...&gt; class ID_STORAGE_TYPE = std::vector, template&lt; typename, typename...&gt; class STORAGE_TYPE = ID_STORAGE_TYPE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflecsi_1_1topo_1_1index__space.html">flecsi::topo::index_space</a>&lt; T, STORAGE, OWNED, SORTED, F, ID_STORAGE_TYPE, STORAGE_TYPE &gt;::apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a959541349f8d2fa3f3c9ff5f0b38b15e">apply_function</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Apply a function f to each indexed entity in the index space, mutating its state. </p>

</div>
</div>
<a class="anchor" id="a94cbee50d03c4a526953ab6f9ef90f60"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool STORAGE = false, bool OWNED = true, bool SORTED = false, class F = void, template&lt; typename, typename...&gt; class ID_STORAGE_TYPE = std::vector, template&lt; typename, typename...&gt; class STORAGE_TYPE = ID_STORAGE_TYPE&gt; </div>
<div class="memtemplate">
template&lt;typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classflecsi_1_1topo_1_1index__space.html">flecsi::topo::index_space</a>&lt; T, STORAGE, OWNED, SORTED, F, ID_STORAGE_TYPE, STORAGE_TYPE &gt;::bin </td>
          <td>(</td>
          <td class="paramtype">Predicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bin entities using a predicate function. </p>
<p>The predicate function returns some sortable key that is used to bin entities.</p>
<p>Predicate The type of the predicate function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The predicate function. Should return a sortable bin key that determines the order of the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of <a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a>'s, with each element corresponding to a specific bin.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This version returns a map </dd></dl>

</div>
</div>
<a class="anchor" id="aaddc6597812ba0610b903a8b5f10a07a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool STORAGE = false, bool OWNED = true, bool SORTED = false, class F = void, template&lt; typename, typename...&gt; class ID_STORAGE_TYPE = std::vector, template&lt; typename, typename...&gt; class STORAGE_TYPE = ID_STORAGE_TYPE&gt; </div>
<div class="memtemplate">
template&lt;typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classflecsi_1_1topo_1_1index__space.html">flecsi::topo::index_space</a>&lt; T, STORAGE, OWNED, SORTED, F, ID_STORAGE_TYPE, STORAGE_TYPE &gt;::bin_as_map </td>
          <td>(</td>
          <td class="paramtype">Predicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bin entities using a predicate function. </p>
<p>The predicate function returns some sortable key that is used to bin entities.</p>
<p>Predicate The type of the predicate function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The predicate function. Should return a sortable bin key that determines the order of the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of <a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a>'s, with each element corresponding to a specific bin.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This version returns a map, and is less costly to bin, but more costly to access. </dd></dl>

</div>
</div>
<a class="anchor" id="afb7e3237cc854d794461ba34a320e208"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool STORAGE = false, bool OWNED = true, bool SORTED = false, class F = void, template&lt; typename, typename...&gt; class ID_STORAGE_TYPE = std::vector, template&lt; typename, typename...&gt; class STORAGE_TYPE = ID_STORAGE_TYPE&gt; </div>
<div class="memtemplate">
template&lt;typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classflecsi_1_1topo_1_1index__space.html">flecsi::topo::index_space</a>&lt; T, STORAGE, OWNED, SORTED, F, ID_STORAGE_TYPE, STORAGE_TYPE &gt;::bin_as_vector </td>
          <td>(</td>
          <td class="paramtype">Predicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bin entities using a predicate function. </p>
<p>The predicate function returns some sortable key that is used to bin entities.</p>
<p>Predicate The type of the predicate function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The predicate function. Should return a sortable bin key that determines the order of the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of <a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a>'s, with each element corresponding to a specific bin.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This version returns a vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a9c0e62b809a7497b76eb2763b988370e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool STORAGE = false, bool OWNED = true, bool SORTED = false, class F = void, template&lt; typename, typename...&gt; class ID_STORAGE_TYPE = std::vector, template&lt; typename, typename...&gt; class STORAGE_TYPE = ID_STORAGE_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class S , bool STORAGE2 = STORAGE, bool OWNED2 = OWNED, bool SORTED2 = SORTED, class F2  = F, template&lt; typename, typename...&gt; class ID_STORAGE_TYPE2 = ID_STORAGE_TYPE, template&lt; typename, typename...&gt; class STORAGE_TYPE2 = STORAGE_TYPE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto&amp; <a class="el" href="classflecsi_1_1topo_1_1index__space.html">flecsi::topo::index_space</a>&lt; T, STORAGE, OWNED, SORTED, F, ID_STORAGE_TYPE, STORAGE_TYPE &gt;::cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cast an index space by re-specifying template parameters such as OWNED or SORTED. </p>

</div>
</div>
<a class="anchor" id="aa7b9bfa8d8e8f4d3bf6ea23247fafdfe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool STORAGE = false, bool OWNED = true, bool SORTED = false, class F = void, template&lt; typename, typename...&gt; class ID_STORAGE_TYPE = std::vector, template&lt; typename, typename...&gt; class STORAGE_TYPE = ID_STORAGE_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class S , bool STORAGE2 = STORAGE, bool OWNED2 = OWNED, bool SORTED2 = SORTED, class F2  = F, template&lt; typename, typename...&gt; class ID_STORAGE_TYPE2 = ID_STORAGE_TYPE, template&lt; typename, typename...&gt; class STORAGE_TYPE2 = STORAGE_TYPE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto&amp; <a class="el" href="classflecsi_1_1topo_1_1index__space.html">flecsi::topo::index_space</a>&lt; T, STORAGE, OWNED, SORTED, F, ID_STORAGE_TYPE, STORAGE_TYPE &gt;::cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cast an index space by re-specifying template parameters such as OWNED or SORTED. </p>

</div>
</div>
<a class="anchor" id="ab75ce8c963afc6894bafa82c658bbe43"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool STORAGE = false, bool OWNED = true, bool SORTED = false, class F = void, template&lt; typename, typename...&gt; class ID_STORAGE_TYPE = std::vector, template&lt; typename, typename...&gt; class STORAGE_TYPE = ID_STORAGE_TYPE&gt; </div>
<div class="memtemplate">
template&lt;typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classflecsi_1_1topo_1_1index__space.html">flecsi::topo::index_space</a>&lt; T, STORAGE, OWNED, SORTED, F, ID_STORAGE_TYPE, STORAGE_TYPE &gt;::filter </td>
          <td>(</td>
          <td class="paramtype">Predicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Walk the index space and apply the predicate f, returning a new index space of those entities for which the predicate returned true.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Predicate</td><td>predicate callable object type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac5b3bb7afbba3c7570cff0b54ce0e366"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool STORAGE = false, bool OWNED = true, bool SORTED = false, class F = void, template&lt; typename, typename...&gt; class ID_STORAGE_TYPE = std::vector, template&lt; typename, typename...&gt; class STORAGE_TYPE = ID_STORAGE_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classflecsi_1_1topo_1_1index__space.html">flecsi::topo::index_space</a>&lt; T, STORAGE, OWNED, SORTED, F, ID_STORAGE_TYPE, STORAGE_TYPE &gt;::map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a88f8ce4670129d53d691c0fb8428112c">map_function</a>&lt; S &gt;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Non mutating method to apply a function f over each entity an index face, returning a new index space in the process </p>

</div>
</div>
<a class="anchor" id="acc1998e93a7aa9dcde6f18b307b17c30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool STORAGE = false, bool OWNED = true, bool SORTED = false, class F = void, template&lt; typename, typename...&gt; class ID_STORAGE_TYPE = std::vector, template&lt; typename, typename...&gt; class STORAGE_TYPE = ID_STORAGE_TYPE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a>&amp; <a class="el" href="classflecsi_1_1topo_1_1index__space.html">flecsi::topo::index_space</a>&lt; T, STORAGE, OWNED, SORTED, F, ID_STORAGE_TYPE, STORAGE_TYPE &gt;::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a>&lt; T, STORAGE, OWNED, SORTED, F, ID_STORAGE_TYPE, STORAGE_TYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>In-place set intersection operation. This method will sort the ID storage if not already sorted and will create a copy of its aliased indices if OWNED is false. </p>

</div>
</div>
<a class="anchor" id="adee51debd9c93e0b7804a360cab409c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool STORAGE = false, bool OWNED = true, bool SORTED = false, class F = void, template&lt; typename, typename...&gt; class ID_STORAGE_TYPE = std::vector, template&lt; typename, typename...&gt; class STORAGE_TYPE = ID_STORAGE_TYPE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classflecsi_1_1topo_1_1index__space.html#a6335bb7fec6f905999eb0bae4df6bcbe">id_t</a>&amp; <a class="el" href="classflecsi_1_1topo_1_1index__space.html">flecsi::topo::index_space</a>&lt; T, STORAGE, OWNED, SORTED, F, ID_STORAGE_TYPE, STORAGE_TYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Index into the index space and return reference to the entity id at index </p>

</div>
</div>
<a class="anchor" id="a23034508aa0245052cf33c35506e6cf8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool STORAGE = false, bool OWNED = true, bool SORTED = false, class F = void, template&lt; typename, typename...&gt; class ID_STORAGE_TYPE = std::vector, template&lt; typename, typename...&gt; class STORAGE_TYPE = ID_STORAGE_TYPE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a6335bb7fec6f905999eb0bae4df6bcbe">id_t</a>&amp; <a class="el" href="classflecsi_1_1topo_1_1index__space.html">flecsi::topo::index_space</a>&lt; T, STORAGE, OWNED, SORTED, F, ID_STORAGE_TYPE, STORAGE_TYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Index into the index space and return reference to the entity id at index </p>

</div>
</div>
<a class="anchor" id="a178825c36c13b9e2076db0faff7026ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool STORAGE = false, bool OWNED = true, bool SORTED = false, class F = void, template&lt; typename, typename...&gt; class ID_STORAGE_TYPE = std::vector, template&lt; typename, typename...&gt; class STORAGE_TYPE = ID_STORAGE_TYPE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a>&amp; <a class="el" href="classflecsi_1_1topo_1_1index__space.html">flecsi::topo::index_space</a>&lt; T, STORAGE, OWNED, SORTED, F, ID_STORAGE_TYPE, STORAGE_TYPE &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a>&lt; T, STORAGE, OWNED, SORTED, F, ID_STORAGE_TYPE, STORAGE_TYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>In-place set complement operator. This method will sort the ID storage if not already sorted and will create a copy of its aliased indices if OWNED is false. </p>

</div>
</div>
<a class="anchor" id="a915a6d81eb6c1a81f2f24364655af10c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool STORAGE = false, bool OWNED = true, bool SORTED = false, class F = void, template&lt; typename, typename...&gt; class ID_STORAGE_TYPE = std::vector, template&lt; typename, typename...&gt; class STORAGE_TYPE = ID_STORAGE_TYPE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a>&amp; <a class="el" href="classflecsi_1_1topo_1_1index__space.html">flecsi::topo::index_space</a>&lt; T, STORAGE, OWNED, SORTED, F, ID_STORAGE_TYPE, STORAGE_TYPE &gt;::operator|= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a>&lt; T, STORAGE, OWNED, SORTED, F, ID_STORAGE_TYPE, STORAGE_TYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>In-place set union operation. This method will sort the ID storage if not already sorted and will create a copy of its aliased indices if OWNED is false. </p>

</div>
</div>
<a class="anchor" id="a7cd0e5f852ed4112c40c2ee02461855d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool STORAGE = false, bool OWNED = true, bool SORTED = false, class F = void, template&lt; typename, typename...&gt; class ID_STORAGE_TYPE = std::vector, template&lt; typename, typename...&gt; class STORAGE_TYPE = ID_STORAGE_TYPE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflecsi_1_1topo_1_1index__space.html">flecsi::topo::index_space</a>&lt; T, STORAGE, OWNED, SORTED, F, ID_STORAGE_TYPE, STORAGE_TYPE &gt;::prepare_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper method, for write operations. If the containers are not owned then make a copy of them internally and set ownership. </p>

</div>
</div>
<a class="anchor" id="a668d5f6196b41b99bf0521eb4d20928c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool STORAGE = false, bool OWNED = true, bool SORTED = false, class F = void, template&lt; typename, typename...&gt; class ID_STORAGE_TYPE = std::vector, template&lt; typename, typename...&gt; class STORAGE_TYPE = ID_STORAGE_TYPE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflecsi_1_1topo_1_1index__space.html">flecsi::topo::index_space</a>&lt; T, STORAGE, OWNED, SORTED, F, ID_STORAGE_TYPE, STORAGE_TYPE &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add an entity to the index space. If the index space does not have storage then only the index is pushed. It will create a copy of its aliased indices if OWNED is false. </p>

</div>
</div>
<a class="anchor" id="af2443937221dd64f620f11a48461dc3d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool STORAGE = false, bool OWNED = true, bool SORTED = false, class F = void, template&lt; typename, typename...&gt; class ID_STORAGE_TYPE = std::vector, template&lt; typename, typename...&gt; class STORAGE_TYPE = ID_STORAGE_TYPE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflecsi_1_1topo_1_1index__space.html">flecsi::topo::index_space</a>&lt; T, STORAGE, OWNED, SORTED, F, ID_STORAGE_TYPE, STORAGE_TYPE &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a6335bb7fec6f905999eb0bae4df6bcbe">id_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add an entity to the index space. If the index space does not have storage then only the index is pushed. It will create a copy of its aliased indices if OWNED is false. </p>

</div>
</div>
<a class="anchor" id="aeedddbb085ae005c75a8f2d32dbefeb1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool STORAGE = false, bool OWNED = true, bool SORTED = false, class F = void, template&lt; typename, typename...&gt; class ID_STORAGE_TYPE = std::vector, template&lt; typename, typename...&gt; class STORAGE_TYPE = ID_STORAGE_TYPE&gt; </div>
<div class="memtemplate">
template&lt;typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S <a class="el" href="classflecsi_1_1topo_1_1index__space.html">flecsi::topo::index_space</a>&lt; T, STORAGE, OWNED, SORTED, F, ID_STORAGE_TYPE, STORAGE_TYPE &gt;::reduce </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflecsi_1_1topo_1_1index__space.html#a7ca0aa21f1184a417e90d80c3b34edd8">reduce_function</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Apply a reduction function to each entity in the index space and return the reduced result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>start value, e.g. 0 for sum, 1 for product </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9486ffbecd5b11ac50843ef51a48f134"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool STORAGE = false, bool OWNED = true, bool SORTED = false, class F = void, template&lt; typename, typename...&gt; class ID_STORAGE_TYPE = std::vector, template&lt; typename, typename...&gt; class STORAGE_TYPE = ID_STORAGE_TYPE&gt; </div>
<div class="memtemplate">
template&lt;bool STORAGE2, bool OWNED2, bool SORTED2, class F2 , template&lt; typename, typename...&gt; class INDEX_STORAGE_TYPE2, template&lt; typename, typename...&gt; class STORAGE_TYPE2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflecsi_1_1topo_1_1index__space.html">flecsi::topo::index_space</a>&lt; T, STORAGE, OWNED, SORTED, F, ID_STORAGE_TYPE, STORAGE_TYPE &gt;::set_master </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a>&lt; T, STORAGE2, OWNED2, SORTED2, F2, INDEX_STORAGE_TYPE2, STORAGE_TYPE2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>master</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the master entity storage. The master owns the actual entities that the index space references. </p>

</div>
</div>
<a class="anchor" id="a0a9bca3fcd07b1fa8522ff454069ee3e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool STORAGE = false, bool OWNED = true, bool SORTED = false, class F = void, template&lt; typename, typename...&gt; class ID_STORAGE_TYPE = std::vector, template&lt; typename, typename...&gt; class STORAGE_TYPE = ID_STORAGE_TYPE&gt; </div>
<div class="memtemplate">
template&lt;bool STORAGE2, bool OWNED2, bool SORTED2, class F2 , template&lt; typename, typename...&gt; class INDEX_STORAGE_TYPE2, template&lt; typename, typename...&gt; class STORAGE_TYPE2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflecsi_1_1topo_1_1index__space.html">flecsi::topo::index_space</a>&lt; T, STORAGE, OWNED, SORTED, F, ID_STORAGE_TYPE, STORAGE_TYPE &gt;::set_master </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflecsi_1_1topo_1_1index__space.html">index_space</a>&lt; T, STORAGE2, OWNED2, SORTED2, F2, INDEX_STORAGE_TYPE2, STORAGE_TYPE2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>master</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the master entity storage. The master owns the actual entities that the index space references. </p>

</div>
</div>
<a class="anchor" id="a6078614baf787bb009502cd5975ef0e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool STORAGE = false, bool OWNED = true, bool SORTED = false, class F = void, template&lt; typename, typename...&gt; class ID_STORAGE_TYPE = std::vector, template&lt; typename, typename...&gt; class STORAGE_TYPE = ID_STORAGE_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class S  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classflecsi_1_1topo_1_1index__space.html">flecsi::topo::index_space</a>&lt; T, STORAGE, OWNED, SORTED, F, ID_STORAGE_TYPE, STORAGE_TYPE &gt;::slice </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Slice and cast an index space. A slice aliases the current index space, definining a new iteration range of offsets to indices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>begin offset </td></tr>
    <tr><td class="paramname">end</td><td>end offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4babfc0b224fde50f1ad9484f4275e89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool STORAGE = false, bool OWNED = true, bool SORTED = false, class F = void, template&lt; typename, typename...&gt; class ID_STORAGE_TYPE = std::vector, template&lt; typename, typename...&gt; class STORAGE_TYPE = ID_STORAGE_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class S  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classflecsi_1_1topo_1_1index__space.html">flecsi::topo::index_space</a>&lt; T, STORAGE, OWNED, SORTED, F, ID_STORAGE_TYPE, STORAGE_TYPE &gt;::slice </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; size_t, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Slice and cast an index space. A slice aliases the current index space, definining a new iteration range of offsets to indices.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>class to cast to</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>offset range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0b551e65bc8aefafeef561b2b8762db0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool STORAGE = false, bool OWNED = true, bool SORTED = false, class F = void, template&lt; typename, typename...&gt; class ID_STORAGE_TYPE = std::vector, template&lt; typename, typename...&gt; class STORAGE_TYPE = ID_STORAGE_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class S  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classflecsi_1_1topo_1_1index__space.html">flecsi::topo::index_space</a>&lt; T, STORAGE, OWNED, SORTED, F, ID_STORAGE_TYPE, STORAGE_TYPE &gt;::slice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cast an index space to use a new entity type. The entity type must be binary compatible with the cast type, i.e. an entity wrapper or derived pointer type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>class to cast to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abf172aec3fa0a8678645e5eb6b96a58d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool STORAGE = false, bool OWNED = true, bool SORTED = false, class F = void, template&lt; typename, typename...&gt; class ID_STORAGE_TYPE = std::vector, template&lt; typename, typename...&gt; class STORAGE_TYPE = ID_STORAGE_TYPE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;const T&gt; <a class="el" href="classflecsi_1_1topo_1_1index__space.html">flecsi::topo::index_space</a>&lt; T, STORAGE, OWNED, SORTED, F, ID_STORAGE_TYPE, STORAGE_TYPE &gt;::to_vec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct and return a vector containing the entities associated with this index space </p>

</div>
</div>
<a class="anchor" id="a9a4dcbaa7af405989cd2f20929be887e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool STORAGE = false, bool OWNED = true, bool SORTED = false, class F = void, template&lt; typename, typename...&gt; class ID_STORAGE_TYPE = std::vector, template&lt; typename, typename...&gt; class STORAGE_TYPE = ID_STORAGE_TYPE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; <a class="el" href="classflecsi_1_1topo_1_1index__space.html">flecsi::topo::index_space</a>&lt; T, STORAGE, OWNED, SORTED, F, ID_STORAGE_TYPE, STORAGE_TYPE &gt;::to_vec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct and return a vector containing the entities associated with this index space </p>

</div>
</div>
<a class="anchor" id="a711ecab3a70c34df57e69d90933282c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool STORAGE = false, bool OWNED = true, bool SORTED = false, class F = void, template&lt; typename, typename...&gt; class ID_STORAGE_TYPE = std::vector, template&lt; typename, typename...&gt; class STORAGE_TYPE = ID_STORAGE_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;S&gt; <a class="el" href="classflecsi_1_1topo_1_1index__space.html">flecsi::topo::index_space</a>&lt; T, STORAGE, OWNED, SORTED, F, ID_STORAGE_TYPE, STORAGE_TYPE &gt;::to_vec_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper method. Construct and return a vector containing the entities associated with this index space.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>entity type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/bergen/devel/tuxfan/flecsi/flecsi/topo/<a class="el" href="index__space_8hh_source.html">index_space.hh</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
